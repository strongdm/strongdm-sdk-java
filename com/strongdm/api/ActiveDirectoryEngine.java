// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protogen. DO NOT EDIT.

package com.strongdm.api;

import java.time.Duration;

public class ActiveDirectoryEngine implements SecretEngine {
  private Duration afterReadTtl;
  /**
   * The default time-to-live duration of the password after it's read. Once the ttl has passed, a
   * password will be rotated.
   */
  public Duration getAfterReadTtl() {
    return this.afterReadTtl;
  }
  /**
   * The default time-to-live duration of the password after it's read. Once the ttl has passed, a
   * password will be rotated.
   */
  public void setAfterReadTtl(Duration in) {
    this.afterReadTtl = in;
  }

  private String binddn;
  /**
   * Distinguished name of object to bind when performing user and group search. Example:
   * cn=vault,ou=Users,dc=example,dc=com
   */
  public String getBinddn() {
    return this.binddn;
  }
  /**
   * Distinguished name of object to bind when performing user and group search. Example:
   * cn=vault,ou=Users,dc=example,dc=com
   */
  public void setBinddn(String in) {
    this.binddn = in;
  }

  private String bindpass;
  /** Password to use along with binddn when performing user search. */
  public String getBindpass() {
    return this.bindpass;
  }
  /** Password to use along with binddn when performing user search. */
  public void setBindpass(String in) {
    this.bindpass = in;
  }

  private String certificate;
  /** CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded. */
  public String getCertificate() {
    return this.certificate;
  }
  /** CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded. */
  public void setCertificate(String in) {
    this.certificate = in;
  }

  private int connectionTimeout;
  /**
   * Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL
   * in the configuration.
   */
  public int getConnectionTimeout() {
    return this.connectionTimeout;
  }
  /**
   * Timeout, in seconds, when attempting to connect to the LDAP server before trying the next URL
   * in the configuration.
   */
  public void setConnectionTimeout(int in) {
    this.connectionTimeout = in;
  }

  private boolean doNotValidateTimestamps;
  /**
   * If set to true this will prevent password change timestamp validation in Active Directory when
   * validating credentials
   */
  public boolean getDoNotValidateTimestamps() {
    return this.doNotValidateTimestamps;
  }
  /**
   * If set to true this will prevent password change timestamp validation in Active Directory when
   * validating credentials
   */
  public void setDoNotValidateTimestamps(boolean in) {
    this.doNotValidateTimestamps = in;
  }

  private String id;
  /** Unique identifier of the Secret Engine. */
  public String getId() {
    return this.id;
  }
  /** Unique identifier of the Secret Engine. */
  public void setId(String in) {
    this.id = in;
  }

  private boolean insecureTls;
  /** If true, skips LDAP server SSL certificate verification - insecure, use with caution! */
  public boolean getInsecureTls() {
    return this.insecureTls;
  }
  /** If true, skips LDAP server SSL certificate verification - insecure, use with caution! */
  public void setInsecureTls(boolean in) {
    this.insecureTls = in;
  }

  private int keyRotationIntervalDays;
  /** An interval of public/private key rotation for secret engine in days */
  public int getKeyRotationIntervalDays() {
    return this.keyRotationIntervalDays;
  }
  /** An interval of public/private key rotation for secret engine in days */
  public void setKeyRotationIntervalDays(int in) {
    this.keyRotationIntervalDays = in;
  }

  private Duration maxBackoffDuration;
  /**
   * The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will
   * be retried in an increasing intervals until it reaches max_backoff_duration
   */
  public Duration getMaxBackoffDuration() {
    return this.maxBackoffDuration;
  }
  /**
   * The maximum retry duration in case of automatic failure. On failed ttl rotation attempt it will
   * be retried in an increasing intervals until it reaches max_backoff_duration
   */
  public void setMaxBackoffDuration(Duration in) {
    this.maxBackoffDuration = in;
  }

  private String name;
  /** Unique human-readable name of the Secret Engine. */
  public String getName() {
    return this.name;
  }
  /** Unique human-readable name of the Secret Engine. */
  public void setName(String in) {
    this.name = in;
  }

  private SecretEnginePolicy policy;
  /** Policy for password creation */
  public SecretEnginePolicy getPolicy() {
    return this.policy;
  }
  /** Policy for password creation */
  public void setPolicy(SecretEnginePolicy in) {
    this.policy = in;
  }

  private byte[] publicKey;
  /** Public key linked with a secret engine */
  public byte[] getPublicKey() {
    return this.publicKey;
  }
  /** Public key linked with a secret engine */
  public void setPublicKey(byte[] in) {
    this.publicKey = in;
  }

  private int requestTimeout;
  /**
   * Timeout, in seconds, for the connection when making requests against the server before
   * returning back an error.
   */
  public int getRequestTimeout() {
    return this.requestTimeout;
  }
  /**
   * Timeout, in seconds, for the connection when making requests against the server before
   * returning back an error.
   */
  public void setRequestTimeout(int in) {
    this.requestTimeout = in;
  }

  private String secretStoreId;
  /** Backing secret store identifier */
  public String getSecretStoreId() {
    return this.secretStoreId;
  }
  /** Backing secret store identifier */
  public void setSecretStoreId(String in) {
    this.secretStoreId = in;
  }

  private String secretStoreRootPath;
  /** Backing Secret Store root path where managed secrets are going to be stored */
  public String getSecretStoreRootPath() {
    return this.secretStoreRootPath;
  }
  /** Backing Secret Store root path where managed secrets are going to be stored */
  public void setSecretStoreRootPath(String in) {
    this.secretStoreRootPath = in;
  }

  private boolean startTls;
  /** If true, issues a StartTLS command after establishing an unencrypted connection. */
  public boolean getStartTls() {
    return this.startTls;
  }
  /** If true, issues a StartTLS command after establishing an unencrypted connection. */
  public void setStartTls(boolean in) {
    this.startTls = in;
  }

  private java.util.Map<String, String> tags;
  /** Tags is a map of key, value pairs. */
  public java.util.Map<String, String> getTags() {
    java.util.Map<String, String> m = new java.util.HashMap<String, String>();
    if (this.tags != null) {
      m.putAll(this.tags);
    }
    return m;
  }
  /** Tags is a map of key, value pairs. */
  public void setTags(java.util.Map<String, String> in) {
    if (in == null) {
      this.tags = null;
      return;
    }
    this.tags = new java.util.HashMap<String, String>();
    this.tags.putAll(in);
  }

  private Duration ttl;
  /**
   * The default password time-to-live duration. Once the ttl has passed, a password will be rotated
   * the next time it's requested.
   */
  public Duration getTtl() {
    return this.ttl;
  }
  /**
   * The default password time-to-live duration. Once the ttl has passed, a password will be rotated
   * the next time it's requested.
   */
  public void setTtl(Duration in) {
    this.ttl = in;
  }

  private String upndomain;
  /** The domain (userPrincipalDomain) used to construct a UPN string for authentication. */
  public String getUpndomain() {
    return this.upndomain;
  }
  /** The domain (userPrincipalDomain) used to construct a UPN string for authentication. */
  public void setUpndomain(String in) {
    this.upndomain = in;
  }

  private String url;
  /** The LDAP server to connect to. */
  public String getUrl() {
    return this.url;
  }
  /** The LDAP server to connect to. */
  public void setUrl(String in) {
    this.url = in;
  }

  private String userdn;
  /** Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com */
  public String getUserdn() {
    return this.userdn;
  }
  /** Base DN under which to perform user search. Example: ou=Users,dc=example,dc=com */
  public void setUserdn(String in) {
    this.userdn = in;
  }
}
