// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by protogen. DO NOT EDIT.

package com.strongdm.api;

import com.google.protobuf.ByteString;
import com.strongdm.api.plumbing.ManagedSecretsPlumbing;
import com.strongdm.api.plumbing.Plumbing;
import com.strongdm.api.plumbing.SecretEngineTypesPlumbing;
import com.strongdm.api.plumbing.SecretEnginesPlumbing;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.MGF1ParameterSpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.concurrent.ConcurrentHashMap;
import javax.crypto.Cipher;
import javax.crypto.spec.OAEPParameterSpec;
import javax.crypto.spec.PSource;

/**
 * SecretEncryptionInterceptor implements encryption for managed secrets. Uses RSA-OAEP with SHA-256
 * and 4096-bit keys.
 */
class SecretEncryptionInterceptor {
  private static final String RSA_ALGORITHM = "RSA";
  private static final String CIPHER_TRANSFORMATION = "RSA/ECB/OAEPPadding";
  private static final int KEY_SIZE = 4096;

  private final Client client;
  private final ConcurrentHashMap<String, PublicKey> publicKeyCache = new ConcurrentHashMap<>();
  private volatile KeyPair ephemeralKeyPair;
  private final Object keyPairLock = new Object();

  SecretEncryptionInterceptor(Client client) {
    this.client = client;
  }

  /** Setup hooks on the method interceptor. */
  void setup(MethodInterceptor interceptor) {
    setupManagedSecretsHooks(interceptor);
    setupSecretEnginesHooks(interceptor);
  }

  // --- Key Management ---

  private KeyPair getEphemeralKeyPair() {
    if (ephemeralKeyPair == null) {
      synchronized (keyPairLock) {
        if (ephemeralKeyPair == null) {
          try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(RSA_ALGORITHM);
            keyGen.initialize(KEY_SIZE, new SecureRandom());
            ephemeralKeyPair = keyGen.generateKeyPair();
          } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("RSA algorithm not available", e);
          }
        }
      }
    }
    return ephemeralKeyPair;
  }

  private byte[] getEphemeralPublicKeyPem() {
    PublicKey publicKey = getEphemeralKeyPair().getPublic();
    byte[] encoded = publicKey.getEncoded();
    String base64 = Base64.getMimeEncoder(64, "\n".getBytes()).encodeToString(encoded);
    return ("-----BEGIN PUBLIC KEY-----\n" + base64 + "\n-----END PUBLIC KEY-----\n").getBytes();
  }

  void cachePublicKey(String engineId, byte[] pemEncodedKey) {
    if (engineId == null || pemEncodedKey == null || pemEncodedKey.length == 0) {
      return;
    }
    try {
      PublicKey key = parsePemPublicKey(pemEncodedKey);
      publicKeyCache.put(engineId, key);
    } catch (IllegalArgumentException
        | IOException
        | java.security.spec.InvalidKeySpecException
        | java.security.NoSuchAlgorithmException e) {
      // Ignore expected parse/key failures - encryption will fail later if key is needed
    }
  }

  private PublicKey getPublicKey(String engineId) {
    return publicKeyCache.get(engineId);
  }

  private PublicKey parsePemPublicKey(byte[] pemData)
      throws IOException, java.security.spec.InvalidKeySpecException,
          java.security.NoSuchAlgorithmException {
    String pem = new String(pemData, java.nio.charset.StandardCharsets.UTF_8);
    boolean isPkcs1 = pem.contains("BEGIN RSA PUBLIC KEY");

    String base64 =
        pem.replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replace("-----BEGIN RSA PUBLIC KEY-----", "")
            .replace("-----END RSA PUBLIC KEY-----", "")
            .replaceAll("\\s", "");

    byte[] keyBytes = Base64.getDecoder().decode(base64);
    KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);

    if (isPkcs1) {
      RSAPublicKeySpec keySpec = parsePkcs1PublicKey(keyBytes);
      return keyFactory.generatePublic(keySpec);
    } else {
      return keyFactory.generatePublic(new X509EncodedKeySpec(keyBytes));
    }
  }

  private RSAPublicKeySpec parsePkcs1PublicKey(byte[] pkcs1Bytes) throws IOException {
    ByteArrayInputStream in = new ByteArrayInputStream(pkcs1Bytes);

    int tag = in.read();
    if (tag != 0x30) {
      throw new IllegalArgumentException("Expected SEQUENCE tag, got: " + tag);
    }
    readLength(in);

    tag = in.read();
    if (tag != 0x02) {
      throw new IllegalArgumentException("Expected INTEGER tag for modulus, got: " + tag);
    }
    int modulusLen = readLength(in);
    byte[] modulusBytes = new byte[modulusLen];
    if (in.read(modulusBytes) != modulusLen) {
      throw new IllegalArgumentException("Failed to read modulus bytes");
    }
    BigInteger modulus = new BigInteger(1, modulusBytes);

    tag = in.read();
    if (tag != 0x02) {
      throw new IllegalArgumentException("Expected INTEGER tag for exponent, got: " + tag);
    }
    int exponentLen = readLength(in);
    byte[] exponentBytes = new byte[exponentLen];
    if (in.read(exponentBytes) != exponentLen) {
      throw new IllegalArgumentException("Failed to read exponent bytes");
    }
    BigInteger exponent = new BigInteger(1, exponentBytes);

    return new RSAPublicKeySpec(modulus, exponent);
  }

  private int readLength(ByteArrayInputStream in) throws IOException {
    int len = in.read();
    if (len < 0x80) {
      return len;
    } else if (len == 0x81) {
      return in.read() & 0xff;
    } else if (len == 0x82) {
      int high = in.read() & 0xff;
      int low = in.read() & 0xff;
      return (high << 8) | low;
    } else if (len == 0x83) {
      int b1 = in.read() & 0xff;
      int b2 = in.read() & 0xff;
      int b3 = in.read() & 0xff;
      return (b1 << 16) | (b2 << 8) | b3;
    } else {
      throw new IllegalArgumentException("Unsupported length encoding: " + len);
    }
  }

  // --- Encryption/Decryption ---

  private byte[] encrypt(PublicKey publicKey, byte[] plaintext) {
    if (plaintext == null || plaintext.length == 0) {
      return plaintext;
    }
    try {
      Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
      OAEPParameterSpec oaepParams =
          new OAEPParameterSpec(
              "SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);
      cipher.init(Cipher.ENCRYPT_MODE, publicKey, oaepParams);
      return cipher.doFinal(plaintext);
    } catch (Exception e) {
      throw new RuntimeException("Failed to encrypt secret", e);
    }
  }

  private byte[] decrypt(byte[] ciphertext) {
    if (ciphertext == null || ciphertext.length == 0) {
      return ciphertext;
    }
    try {
      Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
      OAEPParameterSpec oaepParams =
          new OAEPParameterSpec(
              "SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);
      cipher.init(Cipher.DECRYPT_MODE, getEphemeralKeyPair().getPrivate(), oaepParams);
      return cipher.doFinal(ciphertext);
    } catch (Exception e) {
      throw new RuntimeException("Failed to decrypt secret", e);
    }
  }

  // --- Hook Setup ---

  private void setupManagedSecretsHooks(MethodInterceptor interceptor) {
    // Hook for ManagedSecrets.Create - encrypt before sending
    interceptor.before(
        "ManagedSecrets.Create",
        (ManagedSecretsPlumbing.ManagedSecretCreateRequest req) -> {
          ManagedSecretsPlumbing.ManagedSecret secret = req.getManagedSecret();
          if (secret != null
              && !secret.getValue().isEmpty()
              && !secret.getSecretEngineId().isEmpty()) {
            PublicKey pubKey = getPublicKey(secret.getSecretEngineId());

            // If key not in cache, fetch it
            if (pubKey == null) {
              try {
                client.secretEngines().get(secret.getSecretEngineId());
                pubKey = getPublicKey(secret.getSecretEngineId());
              } catch (Exception e) {
                // If fetch fails, let server handle it
              }
            }

            if (pubKey != null) {
              byte[] encrypted = encrypt(pubKey, secret.getValue().toByteArray());
              ManagedSecretsPlumbing.ManagedSecret encryptedSecret =
                  secret.toBuilder().setValue(ByteString.copyFrom(encrypted)).build();
              return req.toBuilder().setManagedSecret(encryptedSecret).build();
            }
          }
          return req;
        });

    // Hook for ManagedSecrets.Update - encrypt before sending
    interceptor.before(
        "ManagedSecrets.Update",
        (ManagedSecretsPlumbing.ManagedSecretUpdateRequest req) -> {
          ManagedSecretsPlumbing.ManagedSecret secret = req.getManagedSecret();
          if (secret != null
              && !secret.getValue().isEmpty()
              && !secret.getSecretEngineId().isEmpty()) {
            PublicKey pubKey = getPublicKey(secret.getSecretEngineId());

            if (pubKey == null) {
              try {
                client.secretEngines().get(secret.getSecretEngineId());
                pubKey = getPublicKey(secret.getSecretEngineId());
              } catch (Exception e) {
                // If fetch fails, let server handle it
              }
            }

            if (pubKey != null) {
              byte[] encrypted = encrypt(pubKey, secret.getValue().toByteArray());
              ManagedSecretsPlumbing.ManagedSecret encryptedSecret =
                  secret.toBuilder().setValue(ByteString.copyFrom(encrypted)).build();
              return req.toBuilder().setManagedSecret(encryptedSecret).build();
            }
          }
          return req;
        });

    // Hook for ManagedSecrets.Retrieve - add public key before sending
    interceptor.before(
        "ManagedSecrets.Retrieve",
        (ManagedSecretsPlumbing.ManagedSecretRetrieveRequest req) -> {
          if (req.getPublicKey().isEmpty()) {
            return req.toBuilder()
                .setPublicKey(ByteString.copyFrom(getEphemeralPublicKeyPem()))
                .build();
          }
          return req;
        });

    // Hook for ManagedSecrets.Retrieve - decrypt response
    interceptor.after(
        "ManagedSecrets.Retrieve",
        (ManagedSecretsPlumbing.ManagedSecretRetrieveRequest req,
            ManagedSecretsPlumbing.ManagedSecretRetrieveResponse resp) -> {
          // Only decrypt if we provided the public key
          if (!req.getPublicKey().isEmpty()) {
            ManagedSecretsPlumbing.ManagedSecret secret = resp.getManagedSecret();
            if (secret != null && !secret.getValue().isEmpty()) {
              byte[] decrypted = decrypt(secret.getValue().toByteArray());
              ManagedSecretsPlumbing.ManagedSecret decryptedSecret =
                  secret.toBuilder().setValue(ByteString.copyFrom(decrypted)).build();
              return resp.toBuilder().setManagedSecret(decryptedSecret).build();
            }
          }
          return resp;
        });
  }

  private void setupSecretEnginesHooks(MethodInterceptor interceptor) {
    // Hook for SecretEngines.Create - cache public key after response
    interceptor.after(
        "SecretEngines.Create",
        (SecretEnginesPlumbing.SecretEngineCreateRequest req,
            SecretEnginesPlumbing.SecretEngineCreateResponse resp) -> {
          SecretEngineTypesPlumbing.SecretEngine plumbingEngine = resp.getSecretEngine();
          if (plumbingEngine != null) {
            SecretEngine engine = Plumbing.convertSecretEngineToPorcelain(plumbingEngine);
            if (engine != null
                && engine.getId() != null
                && !engine.getId().isEmpty()
                && engine.getPublicKey() != null
                && engine.getPublicKey().length > 0) {
              cachePublicKey(engine.getId(), engine.getPublicKey());
            }
          }
          return resp;
        });

    // Hook for SecretEngines.Get - cache public key after response
    interceptor.after(
        "SecretEngines.Get",
        (SecretEnginesPlumbing.SecretEngineGetRequest req,
            SecretEnginesPlumbing.SecretEngineGetResponse resp) -> {
          SecretEngineTypesPlumbing.SecretEngine plumbingEngine = resp.getSecretEngine();
          if (plumbingEngine != null) {
            SecretEngine engine = Plumbing.convertSecretEngineToPorcelain(plumbingEngine);
            if (engine != null
                && engine.getId() != null
                && !engine.getId().isEmpty()
                && engine.getPublicKey() != null
                && engine.getPublicKey().length > 0) {
              cachePublicKey(engine.getId(), engine.getPublicKey());
            }
          }
          return resp;
        });
  }
}
