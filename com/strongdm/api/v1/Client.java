// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This file was generated by protogen. DO NOT EDIT.

package com.strongdm.api.v1;

import com.google.rpc.Code;
import com.strongdm.api.v1.plumbing.Plumbing;
import io.grpc.ManagedChannel;
import io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.NettyChannelBuilder;
import java.security.MessageDigest;
import java.util.Base64;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

/** Client communicates with the strongDM API. */
public class Client {
  private String apiAccessKey;
  private byte[] apiSecretKey;

  private final int defaultMaxRetries = 3;
  private final int defaultBaseRetryDelay = 30; // 30 ms
  private final int defaultMaxRetryDelay = 300000; // 300 seconds

  private int maxRetries;
  private int baseRetryDelay;
  private int maxRetryDelay;
  private final AccountAttachments accountAttachments;

  /** AccountAttachments assign an account to a role. */
  public AccountAttachments accountAttachments() {
    return this.accountAttachments;
  }

  private final AccountGrants accountGrants;

  /**
   * AccountGrants assign a resource directly to an account, giving the account the permission to
   * connect to that resource.
   */
  public AccountGrants accountGrants() {
    return this.accountGrants;
  }

  private final Accounts accounts;

  /**
   * Accounts are users that have access to strongDM. There are two types of accounts: 1. **Users:**
   * humans who are authenticated through username and password or SSO. 2. **Service Accounts:**
   * machines that are authenticated using a service token.
   */
  public Accounts accounts() {
    return this.accounts;
  }

  private final ControlPanel controlPanel;

  /** ControlPanel contains all administrative controls. */
  public ControlPanel controlPanel() {
    return this.controlPanel;
  }

  private final Nodes nodes;

  /**
   * Nodes make up the strongDM network, and allow your users to connect securely to your resources.
   * There are two types of nodes: - **Gateways** are the entry points into network. They listen for
   * connection from the strongDM client, and provide access to databases and servers. - **Relays**
   * are used to extend the strongDM network into segmented subnets. They provide access to
   * databases and servers but do not listen for incoming connections.
   */
  public Nodes nodes() {
    return this.nodes;
  }

  private final Resources resources;

  /**
   * Resources are databases, servers, clusters, websites, or clouds that strongDM delegates access
   * to.
   */
  public Resources resources() {
    return this.resources;
  }

  private final RoleAttachments roleAttachments;

  /**
   * RoleAttachments represent relationships between composite roles and the roles that make up
   * those composite roles. When a composite role is attached to another role, the permissions
   * granted to members of the composite role are augmented to include the permissions granted to
   * members of the attached role.
   *
   * <p>Deprecated: use multi-role via AccountAttachments instead.
   */
  @Deprecated
  public RoleAttachments roleAttachments() {
    return this.roleAttachments;
  }

  private final RoleGrants roleGrants;

  /**
   * RoleGrants represent relationships between composite roles and the roles that make up those
   * composite roles. When a composite role is attached to another role, the permissions granted to
   * members of the composite role are augmented to include the permissions granted to members of
   * the attached role.
   *
   * <p>Deprecated: use Role access rules instead.
   */
  @Deprecated
  public RoleGrants roleGrants() {
    return this.roleGrants;
  }

  private final Roles roles;

  /**
   * A Role has a list of access rules which determine which Resources the members of the Role have
   * access to. An Account can be a member of multiple Roles via AccountAttachments.
   */
  public Roles roles() {
    return this.roles;
  }

  private final SecretStores secretStores;

  /** SecretStores are servers where resource secrets (passwords, keys) are stored. */
  public SecretStores secretStores() {
    return this.secretStores;
  }
  /** Creates a new strongDM API client. */
  public Client(String apiAccessKey, String apiSecretKey) throws RpcException {
    this(apiAccessKey, apiSecretKey, new ClientOptions());
  }

  /** Creates a new strongDM API client with extra options. */
  public Client(String apiAccessKey, String apiSecretKey, ClientOptions options)
      throws RpcException {
    this.apiAccessKey = apiAccessKey.trim();
    this.apiSecretKey = Base64.getDecoder().decode(apiSecretKey.trim());
    this.maxRetries = this.defaultMaxRetries;
    this.baseRetryDelay = this.defaultBaseRetryDelay;
    this.maxRetryDelay = this.defaultMaxRetryDelay;
    try {
      NettyChannelBuilder builder =
          NettyChannelBuilder.forAddress(options.getHost(), options.getPort());
      if (options.getInsecure()) {
        builder = builder.usePlaintext();
      } else {
        builder = builder.useTransportSecurity().sslContext(GrpcSslContexts.forClient().build());
      }
      this.channel = builder.build();
      this.accountAttachments = new AccountAttachments(this.channel, this);
      this.accountGrants = new AccountGrants(this.channel, this);
      this.accounts = new Accounts(this.channel, this);
      this.controlPanel = new ControlPanel(this.channel, this);
      this.nodes = new Nodes(this.channel, this);
      this.resources = new Resources(this.channel, this);
      this.roleAttachments = new RoleAttachments(this.channel, this);
      this.roleGrants = new RoleGrants(this.channel, this);
      this.roles = new Roles(this.channel, this);
      this.secretStores = new SecretStores(this.channel, this);
    } catch (Exception e) {
      throw Plumbing.convertExceptionToPorcelain(e);
    }
    this.testOptions = new HashMap<String, Object>();
  }

  protected io.grpc.CallCredentials getCallCredentials(
      String methodName, com.google.protobuf.Message req) {
    return new SigningCallCredential(this.apiAccessKey, this.sign(methodName, req.toByteArray()));
  }

  public String sign(String methodName, byte[] message) {
    Calendar utcCalendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    int day = utcCalendar.get(Calendar.DATE);
    int month = utcCalendar.get(Calendar.MONTH) + 1;
    int year = utcCalendar.get(Calendar.YEAR);
    String utcdatestring = String.format("%04d-%02d-%02d", year, month, day);
    try {
      byte[] signingKey = hmac_digest(this.apiSecretKey, utcdatestring.getBytes("UTF-8"));
      signingKey = hmac_digest(signingKey, "sdm_api_v1".getBytes("UTF-8"));

      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      digest.update(methodName.getBytes("UTF-8"));
      digest.update("\n".getBytes("UTF-8"));
      digest.update(message);
      byte[] messageHash = digest.digest();
      return new String(Base64.getEncoder().encode(hmac_digest(signingKey, messageHash)));
    } catch (Exception e) {
      return "";
    }
  }

  private byte[] hmac_digest(byte[] key, byte[] message) {
    try {
      String HMAC_SHA256 = "HmacSHA256";
      Mac sha256_HMAC = Mac.getInstance(HMAC_SHA256);
      SecretKeySpec keySpec = new SecretKeySpec(key, HMAC_SHA256);
      sha256_HMAC.init(keySpec);
      return sha256_HMAC.doFinal(message);
    } catch (Exception e) {
      return new byte[] {};
    }
  }

  private final ManagedChannel channel;

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close() throws InterruptedException {
    return this.close(10, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long secs) throws InterruptedException {
    return this.close(secs, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long timeout, TimeUnit unit) throws InterruptedException {
    if (!this.channel.isShutdown()) {
      this.channel.shutdown();
    }
    if (this.channel.isTerminated()) {
      return true;
    }
    return this.channel.awaitTermination(timeout, unit);
  }

  public void jitterSleep(int iter) {
    int durMax = this.baseRetryDelay * (2 << iter);
    if (durMax > this.maxRetryDelay) {
      durMax = this.maxRetryDelay;
    }
    try {
      Thread.sleep(new Random().nextInt(durMax));
    } catch (Exception e) {
    }
  }

  public boolean shouldRetry(int iter, Exception e) {
    if (iter >= this.maxRetries - 1) {
      return false;
    }
    if (!(e instanceof io.grpc.StatusRuntimeException)) {
      return true;
    }
    com.google.rpc.Status status = io.grpc.protobuf.StatusProto.fromThrowable(e);

    return (status.getCode() == Code.INTERNAL_VALUE);
  }

  protected Map<String, Object> testOptions;
}
