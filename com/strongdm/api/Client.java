// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protogen. DO NOT EDIT.

package com.strongdm.api;

import com.google.rpc.Code;
import com.strongdm.api.plumbing.Plumbing;
import io.grpc.ManagedChannel;
import io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.NettyChannelBuilder;
import java.security.MessageDigest;
import java.util.Base64;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

/** Client communicates with the strongDM API. */
public class Client {
  private String apiAccessKey;
  private byte[] apiSecretKey;

  private final int defaultMaxRetries = 3;
  private final int defaultBaseRetryDelay = 30; // 30 ms
  private final int defaultMaxRetryDelay = 300000; // 300 seconds

  private boolean exposeRateLimitErrors;
  protected int pageLimit = 50;

  private int maxRetries;
  private int baseRetryDelay;
  private int maxRetryDelay;
  protected Date snapshotDate;
  protected final AccessRequests accessRequests;

  /** AccessRequests are requests for access to a resource that may match a Workflow. */
  public AccessRequests accessRequests() {
    return this.accessRequests;
  }

  protected final AccessRequestEventsHistory accessRequestEventsHistory;

  /**
   * AccessRequestEventsHistory provides records of all changes to the state of an AccessRequest.
   */
  public AccessRequestEventsHistory accessRequestEventsHistory() {
    return this.accessRequestEventsHistory;
  }

  protected final AccessRequestsHistory accessRequestsHistory;

  /** AccessRequestsHistory provides records of all changes to the state of an AccessRequest. */
  public AccessRequestsHistory accessRequestsHistory() {
    return this.accessRequestsHistory;
  }

  protected final AccountAttachments accountAttachments;

  /** AccountAttachments assign an account to a role. */
  public AccountAttachments accountAttachments() {
    return this.accountAttachments;
  }

  protected final AccountAttachmentsHistory accountAttachmentsHistory;

  /** AccountAttachmentsHistory records all changes to the state of an AccountAttachment. */
  public AccountAttachmentsHistory accountAttachmentsHistory() {
    return this.accountAttachmentsHistory;
  }

  protected final AccountGrants accountGrants;

  /**
   * AccountGrants assign a resource directly to an account, giving the account the permission to
   * connect to that resource.
   */
  public AccountGrants accountGrants() {
    return this.accountGrants;
  }

  protected final AccountGrantsHistory accountGrantsHistory;

  /** AccountGrantsHistory records all changes to the state of an AccountGrant. */
  public AccountGrantsHistory accountGrantsHistory() {
    return this.accountGrantsHistory;
  }

  protected final AccountPermissions accountPermissions;

  /**
   * AccountPermissions records the granular permissions accounts have, allowing them to execute
   * relevant commands via StrongDM's APIs.
   */
  public AccountPermissions accountPermissions() {
    return this.accountPermissions;
  }

  protected final AccountResources accountResources;

  /**
   * AccountResources enumerates the resources to which accounts have access. The AccountResources
   * service is read-only.
   */
  public AccountResources accountResources() {
    return this.accountResources;
  }

  protected final AccountResourcesHistory accountResourcesHistory;

  /** AccountResourcesHistory records all changes to the state of a AccountResource. */
  public AccountResourcesHistory accountResourcesHistory() {
    return this.accountResourcesHistory;
  }

  protected final Accounts accounts;

  /**
   * Accounts are users that have access to strongDM. There are two types of accounts: 1. **Users:**
   * humans who are authenticated through username and password or SSO. 2. **Service Accounts:**
   * machines that are authenticated using a service token.
   */
  public Accounts accounts() {
    return this.accounts;
  }

  protected final AccountsHistory accountsHistory;

  /** AccountsHistory records all changes to the state of an Account. */
  public AccountsHistory accountsHistory() {
    return this.accountsHistory;
  }

  protected final Activities activities;

  /**
   * An Activity is a record of an action taken against a strongDM deployment, e.g. a user creation,
   * resource deletion, sso configuration change, etc. The Activities service is read-only.
   */
  public Activities activities() {
    return this.activities;
  }

  protected final ApprovalWorkflowApprovers approvalWorkflowApprovers;

  /** ApprovalWorkflowApprovers link approval workflow approvers to an ApprovalWorkflowStep */
  public ApprovalWorkflowApprovers approvalWorkflowApprovers() {
    return this.approvalWorkflowApprovers;
  }

  protected final ApprovalWorkflowApproversHistory approvalWorkflowApproversHistory;

  /**
   * ApprovalWorkflowApproversHistory records all changes to the state of an
   * ApprovalWorkflowApprover.
   */
  public ApprovalWorkflowApproversHistory approvalWorkflowApproversHistory() {
    return this.approvalWorkflowApproversHistory;
  }

  protected final ApprovalWorkflowSteps approvalWorkflowSteps;

  /** ApprovalWorkflowSteps link approval workflow steps to an ApprovalWorkflow */
  public ApprovalWorkflowSteps approvalWorkflowSteps() {
    return this.approvalWorkflowSteps;
  }

  protected final ApprovalWorkflowStepsHistory approvalWorkflowStepsHistory;

  /** ApprovalWorkflowStepsHistory records all changes to the state of an ApprovalWorkflowStep. */
  public ApprovalWorkflowStepsHistory approvalWorkflowStepsHistory() {
    return this.approvalWorkflowStepsHistory;
  }

  protected final ApprovalWorkflows approvalWorkflows;

  /**
   * ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
   * approvers and be approved or denied.
   */
  public ApprovalWorkflows approvalWorkflows() {
    return this.approvalWorkflows;
  }

  protected final ApprovalWorkflowsHistory approvalWorkflowsHistory;

  /** ApprovalWorkflowsHistory records all changes to the state of an ApprovalWorkflow. */
  public ApprovalWorkflowsHistory approvalWorkflowsHistory() {
    return this.approvalWorkflowsHistory;
  }

  protected final ControlPanel controlPanel;

  /** ControlPanel contains all administrative controls. */
  public ControlPanel controlPanel() {
    return this.controlPanel;
  }

  protected final Nodes nodes;

  /**
   * Nodes make up the strongDM network, and allow your users to connect securely to your resources.
   * There are two types of nodes: - **Gateways** are the entry points into network. They listen for
   * connection from the strongDM client, and provide access to databases and servers. - **Relays**
   * are used to extend the strongDM network into segmented subnets. They provide access to
   * databases and servers but do not listen for incoming connections.
   */
  public Nodes nodes() {
    return this.nodes;
  }

  protected final NodesHistory nodesHistory;

  /** NodesHistory records all changes to the state of a Node. */
  public NodesHistory nodesHistory() {
    return this.nodesHistory;
  }

  protected final OrganizationHistory organizationHistory;

  /** OrganizationHistory records all changes to the state of an Organization. */
  public OrganizationHistory organizationHistory() {
    return this.organizationHistory;
  }

  protected final PeeringGroupNodes peeringGroupNodes;

  /**
   * PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering
   * group.
   */
  public PeeringGroupNodes peeringGroupNodes() {
    return this.peeringGroupNodes;
  }

  protected final PeeringGroupPeers peeringGroupPeers;

  /** PeeringGroupPeers provides the building blocks necessary to link two peering groups. */
  public PeeringGroupPeers peeringGroupPeers() {
    return this.peeringGroupPeers;
  }

  protected final PeeringGroupResources peeringGroupResources;

  /**
   * PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a
   * peering group.
   */
  public PeeringGroupResources peeringGroupResources() {
    return this.peeringGroupResources;
  }

  protected final PeeringGroups peeringGroups;

  /**
   * PeeringGroups provides the building blocks necessary to obtain explicit network topology and
   * routing.
   */
  public PeeringGroups peeringGroups() {
    return this.peeringGroups;
  }

  protected final Queries queries;

  /**
   * A Query is a record of a single client request to a resource, such as a SQL query. Long-running
   * SSH, RDP, or Kubernetes interactive sessions also count as queries. The Queries service is
   * read-only.
   */
  public Queries queries() {
    return this.queries;
  }

  protected final RemoteIdentities remoteIdentities;

  /**
   * RemoteIdentities assign a resource directly to an account, giving the account the permission to
   * connect to that resource.
   */
  public RemoteIdentities remoteIdentities() {
    return this.remoteIdentities;
  }

  protected final RemoteIdentitiesHistory remoteIdentitiesHistory;

  /** RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity. */
  public RemoteIdentitiesHistory remoteIdentitiesHistory() {
    return this.remoteIdentitiesHistory;
  }

  protected final RemoteIdentityGroups remoteIdentityGroups;

  /**
   * A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts. An Account's
   * relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
   */
  public RemoteIdentityGroups remoteIdentityGroups() {
    return this.remoteIdentityGroups;
  }

  protected final RemoteIdentityGroupsHistory remoteIdentityGroupsHistory;

  /** RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup. */
  public RemoteIdentityGroupsHistory remoteIdentityGroupsHistory() {
    return this.remoteIdentityGroupsHistory;
  }

  protected final Replays replays;

  /**
   * A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive
   * session (otherwise referred to as a query). The Replays service is read-only.
   */
  public Replays replays() {
    return this.replays;
  }

  protected final Resources resources;

  /**
   * Resources are databases, servers, clusters, websites, or clouds that strongDM delegates access
   * to.
   */
  public Resources resources() {
    return this.resources;
  }

  protected final ResourcesHistory resourcesHistory;

  /** ResourcesHistory records all changes to the state of a Resource. */
  public ResourcesHistory resourcesHistory() {
    return this.resourcesHistory;
  }

  protected final RoleResources roleResources;

  /**
   * RoleResources enumerates the resources to which roles have access. The RoleResources service is
   * read-only.
   */
  public RoleResources roleResources() {
    return this.roleResources;
  }

  protected final RoleResourcesHistory roleResourcesHistory;

  /** RoleResourcesHistory records all changes to the state of a RoleResource. */
  public RoleResourcesHistory roleResourcesHistory() {
    return this.roleResourcesHistory;
  }

  protected final Roles roles;

  /**
   * A Role has a list of access rules which determine which Resources the members of the Role have
   * access to. An Account can be a member of multiple Roles via AccountAttachments.
   */
  public Roles roles() {
    return this.roles;
  }

  protected final RolesHistory rolesHistory;

  /** RolesHistory records all changes to the state of a Role. */
  public RolesHistory rolesHistory() {
    return this.rolesHistory;
  }

  protected final SecretStoreHealths secretStoreHealths;

  /** SecretStoreHealths exposes health states for secret stores. */
  public SecretStoreHealths secretStoreHealths() {
    return this.secretStoreHealths;
  }

  protected final SecretStores secretStores;

  /** SecretStores are servers where resource secrets (passwords, keys) are stored. */
  public SecretStores secretStores() {
    return this.secretStores;
  }

  protected final SecretStoresHistory secretStoresHistory;

  /** SecretStoresHistory records all changes to the state of a SecretStore. */
  public SecretStoresHistory secretStoresHistory() {
    return this.secretStoresHistory;
  }

  protected final WorkflowApprovers workflowApprovers;

  /**
   * WorkflowApprovers is an account or a role with the ability to approve requests bound to a
   * workflow.
   */
  public WorkflowApprovers workflowApprovers() {
    return this.workflowApprovers;
  }

  protected final WorkflowApproversHistory workflowApproversHistory;

  /**
   * WorkflowApproversHistory provides records of all changes to the state of a WorkflowApprover.
   */
  public WorkflowApproversHistory workflowApproversHistory() {
    return this.workflowApproversHistory;
  }

  protected final WorkflowAssignments workflowAssignments;

  /**
   * WorkflowAssignments links a Resource to a Workflow. The assigned resources are those that a
   * user can request access to via the workflow.
   */
  public WorkflowAssignments workflowAssignments() {
    return this.workflowAssignments;
  }

  protected final WorkflowAssignmentsHistory workflowAssignmentsHistory;

  /**
   * WorkflowAssignmentsHistory provides records of all changes to the state of a
   * WorkflowAssignment.
   */
  public WorkflowAssignmentsHistory workflowAssignmentsHistory() {
    return this.workflowAssignmentsHistory;
  }

  protected final WorkflowRoles workflowRoles;

  /**
   * WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a
   * part of to request access to a resource via the workflow.
   */
  public WorkflowRoles workflowRoles() {
    return this.workflowRoles;
  }

  protected final WorkflowRolesHistory workflowRolesHistory;

  /** WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole */
  public WorkflowRolesHistory workflowRolesHistory() {
    return this.workflowRolesHistory;
  }

  protected final Workflows workflows;

  /**
   * Workflows are the collection of rules that define the resources to which access can be
   * requested, the users that can request that access, and the mechanism for approving those
   * requests which can either be automatic approval or a set of users authorized to approve the
   * requests.
   */
  public Workflows workflows() {
    return this.workflows;
  }

  protected final WorkflowsHistory workflowsHistory;

  /** WorkflowsHistory provides records of all changes to the state of a Workflow. */
  public WorkflowsHistory workflowsHistory() {
    return this.workflowsHistory;
  }
  /** Creates a new strongDM API client. */
  public Client(String apiAccessKey, String apiSecretKey) throws RpcException {
    this(apiAccessKey, apiSecretKey, new ClientOptions());
  }

  private Client(Client client) {
    this.apiAccessKey = client.apiAccessKey;
    this.apiSecretKey = client.apiSecretKey;
    this.maxRetries = client.defaultMaxRetries;
    this.baseRetryDelay = client.defaultBaseRetryDelay;
    this.maxRetryDelay = client.defaultMaxRetryDelay;
    this.exposeRateLimitErrors = client.exposeRateLimitErrors;
    this.pageLimit = client.pageLimit;
    this.channel = client.channel;
    this.snapshotDate = client.snapshotDate;
    this.accessRequests = new AccessRequests(this.channel, this);
    this.accessRequestEventsHistory = new AccessRequestEventsHistory(this.channel, this);
    this.accessRequestsHistory = new AccessRequestsHistory(this.channel, this);
    this.accountAttachments = new AccountAttachments(this.channel, this);
    this.accountAttachmentsHistory = new AccountAttachmentsHistory(this.channel, this);
    this.accountGrants = new AccountGrants(this.channel, this);
    this.accountGrantsHistory = new AccountGrantsHistory(this.channel, this);
    this.accountPermissions = new AccountPermissions(this.channel, this);
    this.accountResources = new AccountResources(this.channel, this);
    this.accountResourcesHistory = new AccountResourcesHistory(this.channel, this);
    this.accounts = new Accounts(this.channel, this);
    this.accountsHistory = new AccountsHistory(this.channel, this);
    this.activities = new Activities(this.channel, this);
    this.approvalWorkflowApprovers = new ApprovalWorkflowApprovers(this.channel, this);
    this.approvalWorkflowApproversHistory =
        new ApprovalWorkflowApproversHistory(this.channel, this);
    this.approvalWorkflowSteps = new ApprovalWorkflowSteps(this.channel, this);
    this.approvalWorkflowStepsHistory = new ApprovalWorkflowStepsHistory(this.channel, this);
    this.approvalWorkflows = new ApprovalWorkflows(this.channel, this);
    this.approvalWorkflowsHistory = new ApprovalWorkflowsHistory(this.channel, this);
    this.controlPanel = new ControlPanel(this.channel, this);
    this.nodes = new Nodes(this.channel, this);
    this.nodesHistory = new NodesHistory(this.channel, this);
    this.organizationHistory = new OrganizationHistory(this.channel, this);
    this.peeringGroupNodes = new PeeringGroupNodes(this.channel, this);
    this.peeringGroupPeers = new PeeringGroupPeers(this.channel, this);
    this.peeringGroupResources = new PeeringGroupResources(this.channel, this);
    this.peeringGroups = new PeeringGroups(this.channel, this);
    this.queries = new Queries(this.channel, this);
    this.remoteIdentities = new RemoteIdentities(this.channel, this);
    this.remoteIdentitiesHistory = new RemoteIdentitiesHistory(this.channel, this);
    this.remoteIdentityGroups = new RemoteIdentityGroups(this.channel, this);
    this.remoteIdentityGroupsHistory = new RemoteIdentityGroupsHistory(this.channel, this);
    this.replays = new Replays(this.channel, this);
    this.resources = new Resources(this.channel, this);
    this.resourcesHistory = new ResourcesHistory(this.channel, this);
    this.roleResources = new RoleResources(this.channel, this);
    this.roleResourcesHistory = new RoleResourcesHistory(this.channel, this);
    this.roles = new Roles(this.channel, this);
    this.rolesHistory = new RolesHistory(this.channel, this);
    this.secretStoreHealths = new SecretStoreHealths(this.channel, this);
    this.secretStores = new SecretStores(this.channel, this);
    this.secretStoresHistory = new SecretStoresHistory(this.channel, this);
    this.workflowApprovers = new WorkflowApprovers(this.channel, this);
    this.workflowApproversHistory = new WorkflowApproversHistory(this.channel, this);
    this.workflowAssignments = new WorkflowAssignments(this.channel, this);
    this.workflowAssignmentsHistory = new WorkflowAssignmentsHistory(this.channel, this);
    this.workflowRoles = new WorkflowRoles(this.channel, this);
    this.workflowRolesHistory = new WorkflowRolesHistory(this.channel, this);
    this.workflows = new Workflows(this.channel, this);
    this.workflowsHistory = new WorkflowsHistory(this.channel, this);
    this.testOptions = client.testOptions;
  }

  /** Creates a new strongDM API client with extra options. */
  public Client(String apiAccessKey, String apiSecretKey, ClientOptions options)
      throws RpcException {
    this.apiAccessKey = apiAccessKey.trim();
    this.apiSecretKey = Base64.getDecoder().decode(apiSecretKey.trim());
    this.maxRetries = this.defaultMaxRetries;
    this.baseRetryDelay = this.defaultBaseRetryDelay;
    this.maxRetryDelay = this.defaultMaxRetryDelay;
    this.pageLimit = options.getPageLimit();
    this.exposeRateLimitErrors = options.getExposeRateLimitErrors();
    try {
      NettyChannelBuilder builder =
          NettyChannelBuilder.forAddress(options.getHost(), options.getPort());
      if (options.getInsecure()) {
        builder = builder.usePlaintext();
      } else {
        builder = builder.useTransportSecurity().sslContext(GrpcSslContexts.forClient().build());
      }
      this.channel = builder.build();
      this.accessRequests = new AccessRequests(this.channel, this);
      this.accessRequestEventsHistory = new AccessRequestEventsHistory(this.channel, this);
      this.accessRequestsHistory = new AccessRequestsHistory(this.channel, this);
      this.accountAttachments = new AccountAttachments(this.channel, this);
      this.accountAttachmentsHistory = new AccountAttachmentsHistory(this.channel, this);
      this.accountGrants = new AccountGrants(this.channel, this);
      this.accountGrantsHistory = new AccountGrantsHistory(this.channel, this);
      this.accountPermissions = new AccountPermissions(this.channel, this);
      this.accountResources = new AccountResources(this.channel, this);
      this.accountResourcesHistory = new AccountResourcesHistory(this.channel, this);
      this.accounts = new Accounts(this.channel, this);
      this.accountsHistory = new AccountsHistory(this.channel, this);
      this.activities = new Activities(this.channel, this);
      this.approvalWorkflowApprovers = new ApprovalWorkflowApprovers(this.channel, this);
      this.approvalWorkflowApproversHistory =
          new ApprovalWorkflowApproversHistory(this.channel, this);
      this.approvalWorkflowSteps = new ApprovalWorkflowSteps(this.channel, this);
      this.approvalWorkflowStepsHistory = new ApprovalWorkflowStepsHistory(this.channel, this);
      this.approvalWorkflows = new ApprovalWorkflows(this.channel, this);
      this.approvalWorkflowsHistory = new ApprovalWorkflowsHistory(this.channel, this);
      this.controlPanel = new ControlPanel(this.channel, this);
      this.nodes = new Nodes(this.channel, this);
      this.nodesHistory = new NodesHistory(this.channel, this);
      this.organizationHistory = new OrganizationHistory(this.channel, this);
      this.peeringGroupNodes = new PeeringGroupNodes(this.channel, this);
      this.peeringGroupPeers = new PeeringGroupPeers(this.channel, this);
      this.peeringGroupResources = new PeeringGroupResources(this.channel, this);
      this.peeringGroups = new PeeringGroups(this.channel, this);
      this.queries = new Queries(this.channel, this);
      this.remoteIdentities = new RemoteIdentities(this.channel, this);
      this.remoteIdentitiesHistory = new RemoteIdentitiesHistory(this.channel, this);
      this.remoteIdentityGroups = new RemoteIdentityGroups(this.channel, this);
      this.remoteIdentityGroupsHistory = new RemoteIdentityGroupsHistory(this.channel, this);
      this.replays = new Replays(this.channel, this);
      this.resources = new Resources(this.channel, this);
      this.resourcesHistory = new ResourcesHistory(this.channel, this);
      this.roleResources = new RoleResources(this.channel, this);
      this.roleResourcesHistory = new RoleResourcesHistory(this.channel, this);
      this.roles = new Roles(this.channel, this);
      this.rolesHistory = new RolesHistory(this.channel, this);
      this.secretStoreHealths = new SecretStoreHealths(this.channel, this);
      this.secretStores = new SecretStores(this.channel, this);
      this.secretStoresHistory = new SecretStoresHistory(this.channel, this);
      this.workflowApprovers = new WorkflowApprovers(this.channel, this);
      this.workflowApproversHistory = new WorkflowApproversHistory(this.channel, this);
      this.workflowAssignments = new WorkflowAssignments(this.channel, this);
      this.workflowAssignmentsHistory = new WorkflowAssignmentsHistory(this.channel, this);
      this.workflowRoles = new WorkflowRoles(this.channel, this);
      this.workflowRolesHistory = new WorkflowRolesHistory(this.channel, this);
      this.workflows = new Workflows(this.channel, this);
      this.workflowsHistory = new WorkflowsHistory(this.channel, this);
    } catch (Exception e) {
      throw Plumbing.convertExceptionToPorcelain(e);
    }
    this.testOptions = new HashMap<String, Object>();
  }

  public SnapshotClient snapshotAt(Date date) {
    Client copy = new Client(this);
    copy.snapshotDate = date;
    return new SnapshotClient(copy);
  }

  protected io.grpc.CallCredentials getCallCredentials(
      String methodName, com.google.protobuf.Message req) {
    return new SigningCallCredential(this.apiAccessKey, this.sign(methodName, req.toByteArray()));
  }

  public String sign(String methodName, byte[] message) {
    Calendar utcCalendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    int day = utcCalendar.get(Calendar.DATE);
    int month = utcCalendar.get(Calendar.MONTH) + 1;
    int year = utcCalendar.get(Calendar.YEAR);
    String utcdatestring = String.format("%04d-%02d-%02d", year, month, day);
    try {
      byte[] signingKey = hmac_digest(this.apiSecretKey, utcdatestring.getBytes("UTF-8"));
      signingKey = hmac_digest(signingKey, "sdm_api_v1".getBytes("UTF-8"));

      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      digest.update(methodName.getBytes("UTF-8"));
      digest.update("\n".getBytes("UTF-8"));
      digest.update(message);
      byte[] messageHash = digest.digest();
      return new String(Base64.getEncoder().encode(hmac_digest(signingKey, messageHash)));
    } catch (Exception e) {
      return "";
    }
  }

  private byte[] hmac_digest(byte[] key, byte[] message) {
    try {
      String HMAC_SHA256 = "HmacSHA256";
      Mac sha256_HMAC = Mac.getInstance(HMAC_SHA256);
      SecretKeySpec keySpec = new SecretKeySpec(key, HMAC_SHA256);
      sha256_HMAC.init(keySpec);
      return sha256_HMAC.doFinal(message);
    } catch (Exception e) {
      return new byte[] {};
    }
  }

  private final ManagedChannel channel;

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close() throws InterruptedException {
    return this.close(10, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long secs) throws InterruptedException {
    return this.close(secs, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long timeout, TimeUnit unit) throws InterruptedException {
    if (!this.channel.isShutdown()) {
      this.channel.shutdown();
    }
    if (this.channel.isTerminated()) {
      return true;
    }
    return this.channel.awaitTermination(timeout, unit);
  }

  public void jitterSleep(int iter) {
    int durMax = this.baseRetryDelay * (2 << iter);
    if (durMax > this.maxRetryDelay) {
      durMax = this.maxRetryDelay;
    }
    try {
      Thread.sleep(new Random().nextInt(durMax));
    } catch (Exception e) {
    }
  }

  public boolean shouldRetry(int iter, Exception e) {
    if (iter >= this.maxRetries - 1) {
      return false;
    }
    if (!(e instanceof io.grpc.StatusRuntimeException)) {
      return true;
    }
    com.google.rpc.Status status = io.grpc.protobuf.StatusProto.fromThrowable(e);
    if (!this.exposeRateLimitErrors) {
      Exception porcelain = Plumbing.convertExceptionToPorcelain(e);
      if (porcelain instanceof RateLimitException) {
        long now = System.currentTimeMillis();
        RateLimitException rle = (RateLimitException) porcelain;
        long resetAt = rle.getRateLimit().getResetAt().toInstant().toEpochMilli();
        long waitFor = resetAt - now;
        // If timezones or clock drift causes this calculation to fail,
        // wait at most one minute.
        if ((waitFor < 0) || (waitFor > 1000 * 60)) {
          waitFor = 1000 * 60;
        }
        try {
          Thread.sleep(waitFor);
        } catch (Exception e2) {
        }
        return true;
      }
    }

    return (status.getCode() == Code.INTERNAL_VALUE || status.getCode() == Code.UNAVAILABLE_VALUE);
  }

  protected Map<String, Object> testOptions;
}
