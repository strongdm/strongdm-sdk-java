// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protogen. DO NOT EDIT.

package com.strongdm.api;

import com.google.rpc.Code;
import com.strongdm.api.plumbing.Plumbing;
import io.grpc.Deadline;
import io.grpc.ManagedChannel;
import io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.NettyChannelBuilder;
import java.security.MessageDigest;
import java.util.Base64;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

/** Client communicates with the strongDM API. */
public class Client {
  private String apiAccessKey;
  private byte[] apiSecretKey;

  private boolean retryRateLimitErrors;
  protected int pageLimit;

  private int baseRetryDelay = 1000; // 1 second
  private int maxRetryDelay = 120000; // 120 seconds
  private double retryFactor = 1.6;
  private double retryJitter = 0.2;
  protected Date snapshotDate;
  protected final AccessRequests accessRequests;

  /** AccessRequests are requests for access to a resource that may match a Workflow. */
  public AccessRequests accessRequests() {
    return this.accessRequests;
  }

  protected final AccessRequestEventsHistory accessRequestEventsHistory;

  /**
   * AccessRequestEventsHistory provides records of all changes to the state of an AccessRequest.
   */
  public AccessRequestEventsHistory accessRequestEventsHistory() {
    return this.accessRequestEventsHistory;
  }

  protected final AccessRequestsHistory accessRequestsHistory;

  /** AccessRequestsHistory provides records of all changes to the state of an AccessRequest. */
  public AccessRequestsHistory accessRequestsHistory() {
    return this.accessRequestsHistory;
  }

  protected final AccountAttachments accountAttachments;

  /** AccountAttachments assign an account to a role. */
  public AccountAttachments accountAttachments() {
    return this.accountAttachments;
  }

  protected final AccountAttachmentsHistory accountAttachmentsHistory;

  /** AccountAttachmentsHistory records all changes to the state of an AccountAttachment. */
  public AccountAttachmentsHistory accountAttachmentsHistory() {
    return this.accountAttachmentsHistory;
  }

  protected final AccountGrants accountGrants;

  /**
   * AccountGrants assign a resource directly to an account, giving the account the permission to
   * connect to that resource.
   */
  public AccountGrants accountGrants() {
    return this.accountGrants;
  }

  protected final AccountGrantsHistory accountGrantsHistory;

  /** AccountGrantsHistory records all changes to the state of an AccountGrant. */
  public AccountGrantsHistory accountGrantsHistory() {
    return this.accountGrantsHistory;
  }

  protected final AccountPermissions accountPermissions;

  /**
   * AccountPermissions records the granular permissions accounts have, allowing them to execute
   * relevant commands via StrongDM's APIs.
   */
  public AccountPermissions accountPermissions() {
    return this.accountPermissions;
  }

  protected final AccountResources accountResources;

  /**
   * AccountResources enumerates the resources to which accounts have access. The AccountResources
   * service is read-only.
   */
  public AccountResources accountResources() {
    return this.accountResources;
  }

  protected final AccountResourcesHistory accountResourcesHistory;

  /** AccountResourcesHistory records all changes to the state of a AccountResource. */
  public AccountResourcesHistory accountResourcesHistory() {
    return this.accountResourcesHistory;
  }

  protected final Accounts accounts;

  /**
   * Accounts are users that have access to strongDM. There are two types of accounts: 1. **Users:**
   * humans who are authenticated through username and password or SSO. 2. **Service Accounts:**
   * machines that are authenticated using a service token. 3. **Tokens** are access keys with
   * permissions that can be used for authentication.
   */
  public Accounts accounts() {
    return this.accounts;
  }

  protected final AccountsHistory accountsHistory;

  /** AccountsHistory records all changes to the state of an Account. */
  public AccountsHistory accountsHistory() {
    return this.accountsHistory;
  }

  protected final Activities activities;

  /**
   * An Activity is a record of an action taken against a strongDM deployment, e.g. a user creation,
   * resource deletion, sso configuration change, etc. The Activities service is read-only.
   */
  public Activities activities() {
    return this.activities;
  }

  protected final ApprovalWorkflowApprovers approvalWorkflowApprovers;

  /** ApprovalWorkflowApprovers link approval workflow approvers to an ApprovalWorkflowStep */
  @Deprecated
  public ApprovalWorkflowApprovers approvalWorkflowApprovers() {
    return this.approvalWorkflowApprovers;
  }

  protected final ApprovalWorkflowApproversHistory approvalWorkflowApproversHistory;

  /**
   * ApprovalWorkflowApproversHistory records all changes to the state of an
   * ApprovalWorkflowApprover.
   */
  public ApprovalWorkflowApproversHistory approvalWorkflowApproversHistory() {
    return this.approvalWorkflowApproversHistory;
  }

  protected final ApprovalWorkflowSteps approvalWorkflowSteps;

  /** ApprovalWorkflowSteps link approval workflow steps to an ApprovalWorkflow */
  @Deprecated
  public ApprovalWorkflowSteps approvalWorkflowSteps() {
    return this.approvalWorkflowSteps;
  }

  protected final ApprovalWorkflowStepsHistory approvalWorkflowStepsHistory;

  /** ApprovalWorkflowStepsHistory records all changes to the state of an ApprovalWorkflowStep. */
  public ApprovalWorkflowStepsHistory approvalWorkflowStepsHistory() {
    return this.approvalWorkflowStepsHistory;
  }

  protected final ApprovalWorkflows approvalWorkflows;

  /**
   * ApprovalWorkflows are the mechanism by which requests for access can be viewed by authorized
   * approvers and be approved or denied.
   */
  public ApprovalWorkflows approvalWorkflows() {
    return this.approvalWorkflows;
  }

  protected final ApprovalWorkflowsHistory approvalWorkflowsHistory;

  /** ApprovalWorkflowsHistory records all changes to the state of an ApprovalWorkflow. */
  public ApprovalWorkflowsHistory approvalWorkflowsHistory() {
    return this.approvalWorkflowsHistory;
  }

  protected final ControlPanel controlPanel;

  /** ControlPanel contains all administrative controls. */
  public ControlPanel controlPanel() {
    return this.controlPanel;
  }

  protected final HealthChecks healthChecks;

  /**
   * HealthChecks lists the last healthcheck between each node and resource. Note the unconventional
   * capitalization here is to prevent having a collision with GRPC
   */
  public HealthChecks healthChecks() {
    return this.healthChecks;
  }

  protected final IdentityAliases identityAliases;

  /**
   * IdentityAliases assign an alias to an account within an IdentitySet. The alias is used as the
   * username when connecting to a identity supported resource.
   */
  public IdentityAliases identityAliases() {
    return this.identityAliases;
  }

  protected final IdentityAliasesHistory identityAliasesHistory;

  /** IdentityAliasesHistory records all changes to the state of a IdentityAlias. */
  public IdentityAliasesHistory identityAliasesHistory() {
    return this.identityAliasesHistory;
  }

  protected final IdentitySets identitySets;

  /**
   * A IdentitySet is a named grouping of Identity Aliases for Accounts. An Account's relationship
   * to a IdentitySet is defined via IdentityAlias objects.
   */
  public IdentitySets identitySets() {
    return this.identitySets;
  }

  protected final IdentitySetsHistory identitySetsHistory;

  /** IdentitySetsHistory records all changes to the state of a IdentitySet. */
  public IdentitySetsHistory identitySetsHistory() {
    return this.identitySetsHistory;
  }

  protected final ManagedSecrets managedSecrets;

  /**
   * ManagedSecret is a private vertical for creating, reading, updating, deleting, listing and
   * rotating the managed secrets in the secrets engines as an authenticated user.
   */
  public ManagedSecrets managedSecrets() {
    return this.managedSecrets;
  }

  protected final Nodes nodes;

  /**
   * Nodes make up the strongDM network, and allow your users to connect securely to your resources.
   * There are two types of nodes: - **Gateways** are the entry points into network. They listen for
   * connection from the strongDM client, and provide access to databases and servers. - **Relays**
   * are used to extend the strongDM network into segmented subnets. They provide access to
   * databases and servers but do not listen for incoming connections.
   */
  public Nodes nodes() {
    return this.nodes;
  }

  protected final NodesHistory nodesHistory;

  /** NodesHistory records all changes to the state of a Node. */
  public NodesHistory nodesHistory() {
    return this.nodesHistory;
  }

  protected final OrganizationHistory organizationHistory;

  /** OrganizationHistory records all changes to the state of an Organization. */
  public OrganizationHistory organizationHistory() {
    return this.organizationHistory;
  }

  protected final PeeringGroupNodes peeringGroupNodes;

  /**
   * PeeringGroupNodes provides the building blocks necessary to obtain attach a node to a peering
   * group.
   */
  public PeeringGroupNodes peeringGroupNodes() {
    return this.peeringGroupNodes;
  }

  protected final PeeringGroupPeers peeringGroupPeers;

  /** PeeringGroupPeers provides the building blocks necessary to link two peering groups. */
  public PeeringGroupPeers peeringGroupPeers() {
    return this.peeringGroupPeers;
  }

  protected final PeeringGroupResources peeringGroupResources;

  /**
   * PeeringGroupResources provides the building blocks necessary to obtain attach a resource to a
   * peering group.
   */
  public PeeringGroupResources peeringGroupResources() {
    return this.peeringGroupResources;
  }

  protected final PeeringGroups peeringGroups;

  /**
   * PeeringGroups provides the building blocks necessary to obtain explicit network topology and
   * routing.
   */
  public PeeringGroups peeringGroups() {
    return this.peeringGroups;
  }

  protected final Policies policies;

  /**
   * Policies are the collection of one or more statements that enforce fine-grained access control
   * for the users of an organization.
   */
  public Policies policies() {
    return this.policies;
  }

  protected final PoliciesHistory policiesHistory;

  /** PoliciesHistory records all changes to the state of a Policy. */
  public PoliciesHistory policiesHistory() {
    return this.policiesHistory;
  }

  protected final ProxyClusterKeys proxyClusterKeys;

  /**
   * Proxy Cluster Keys are authentication keys for all proxies within a cluster. The proxies within
   * a cluster share the same key. One cluster can have multiple keys in order to facilitate key
   * rotation.
   */
  public ProxyClusterKeys proxyClusterKeys() {
    return this.proxyClusterKeys;
  }

  protected final Queries queries;

  /**
   * A Query is a record of a single client request to a resource, such as a SQL query. Long-running
   * SSH, RDP, or Kubernetes interactive sessions also count as queries. The Queries service is
   * read-only.
   */
  public Queries queries() {
    return this.queries;
  }

  protected final RemoteIdentities remoteIdentities;

  /**
   * RemoteIdentities assign a resource directly to an account, giving the account the permission to
   * connect to that resource.
   */
  @Deprecated
  public RemoteIdentities remoteIdentities() {
    return this.remoteIdentities;
  }

  protected final RemoteIdentitiesHistory remoteIdentitiesHistory;

  /** RemoteIdentitiesHistory records all changes to the state of a RemoteIdentity. */
  @Deprecated
  public RemoteIdentitiesHistory remoteIdentitiesHistory() {
    return this.remoteIdentitiesHistory;
  }

  protected final RemoteIdentityGroups remoteIdentityGroups;

  /**
   * A RemoteIdentityGroup is a named grouping of Remote Identities for Accounts. An Account's
   * relationship to a RemoteIdentityGroup is defined via RemoteIdentity objects.
   */
  @Deprecated
  public RemoteIdentityGroups remoteIdentityGroups() {
    return this.remoteIdentityGroups;
  }

  protected final RemoteIdentityGroupsHistory remoteIdentityGroupsHistory;

  /** RemoteIdentityGroupsHistory records all changes to the state of a RemoteIdentityGroup. */
  @Deprecated
  public RemoteIdentityGroupsHistory remoteIdentityGroupsHistory() {
    return this.remoteIdentityGroupsHistory;
  }

  protected final Replays replays;

  /**
   * A Replay captures the data transferred over a long-running SSH, RDP, or Kubernetes interactive
   * session (otherwise referred to as a query). The Replays service is read-only.
   */
  public Replays replays() {
    return this.replays;
  }

  protected final Resources resources;

  /**
   * Resources are databases, servers, clusters, websites, or clouds that strongDM delegates access
   * to.
   */
  public Resources resources() {
    return this.resources;
  }

  protected final ResourcesHistory resourcesHistory;

  /** ResourcesHistory records all changes to the state of a Resource. */
  public ResourcesHistory resourcesHistory() {
    return this.resourcesHistory;
  }

  protected final RoleResources roleResources;

  /**
   * RoleResources enumerates the resources to which roles have access. The RoleResources service is
   * read-only.
   */
  public RoleResources roleResources() {
    return this.roleResources;
  }

  protected final RoleResourcesHistory roleResourcesHistory;

  /** RoleResourcesHistory records all changes to the state of a RoleResource. */
  public RoleResourcesHistory roleResourcesHistory() {
    return this.roleResourcesHistory;
  }

  protected final Roles roles;

  /**
   * A Role has a list of access rules which determine which Resources the members of the Role have
   * access to. An Account can be a member of multiple Roles via AccountAttachments.
   */
  public Roles roles() {
    return this.roles;
  }

  protected final RolesHistory rolesHistory;

  /** RolesHistory records all changes to the state of a Role. */
  public RolesHistory rolesHistory() {
    return this.rolesHistory;
  }

  protected final SecretStores secretStores;

  /** SecretStores are servers where resource secrets (passwords, keys) are stored. */
  public SecretStores secretStores() {
    return this.secretStores;
  }

  protected final SecretEngines secretEngines;

  /** */
  public SecretEngines secretEngines() {
    return this.secretEngines;
  }

  protected final SecretStoreHealths secretStoreHealths;

  /** SecretStoreHealths exposes health states for secret stores. */
  public SecretStoreHealths secretStoreHealths() {
    return this.secretStoreHealths;
  }

  protected final SecretStoresHistory secretStoresHistory;

  /** SecretStoresHistory records all changes to the state of a SecretStore. */
  public SecretStoresHistory secretStoresHistory() {
    return this.secretStoresHistory;
  }

  protected final WorkflowApprovers workflowApprovers;

  /**
   * WorkflowApprovers is an account or a role with the ability to approve requests bound to a
   * workflow.
   */
  public WorkflowApprovers workflowApprovers() {
    return this.workflowApprovers;
  }

  protected final WorkflowApproversHistory workflowApproversHistory;

  /**
   * WorkflowApproversHistory provides records of all changes to the state of a WorkflowApprover.
   */
  public WorkflowApproversHistory workflowApproversHistory() {
    return this.workflowApproversHistory;
  }

  protected final WorkflowRoles workflowRoles;

  /**
   * WorkflowRole links a role to a workflow. The linked roles indicate which roles a user must be a
   * part of to request access to a resource via the workflow.
   */
  public WorkflowRoles workflowRoles() {
    return this.workflowRoles;
  }

  protected final WorkflowRolesHistory workflowRolesHistory;

  /** WorkflowRolesHistory provides records of all changes to the state of a WorkflowRole */
  public WorkflowRolesHistory workflowRolesHistory() {
    return this.workflowRolesHistory;
  }

  protected final Workflows workflows;

  /**
   * Workflows are the collection of rules that define the resources to which access can be
   * requested, the users that can request that access, and the mechanism for approving those
   * requests which can either be automatic approval or a set of users authorized to approve the
   * requests.
   */
  public Workflows workflows() {
    return this.workflows;
  }

  protected final WorkflowsHistory workflowsHistory;

  /** WorkflowsHistory provides records of all changes to the state of a Workflow. */
  public WorkflowsHistory workflowsHistory() {
    return this.workflowsHistory;
  }
  /** Creates a new strongDM API client. */
  public Client(String apiAccessKey, String apiSecretKey) throws RpcException {
    this(apiAccessKey, apiSecretKey, new ClientOptions());
  }

  private Client(Client client) {
    this.apiAccessKey = client.apiAccessKey;
    this.apiSecretKey = client.apiSecretKey;
    this.baseRetryDelay = client.baseRetryDelay;
    this.maxRetryDelay = client.maxRetryDelay;
    this.retryRateLimitErrors = client.retryRateLimitErrors;
    this.retryFactor = client.retryFactor;
    this.retryJitter = client.retryJitter;
    this.pageLimit = client.pageLimit;
    this.channel = client.channel;
    this.snapshotDate = client.snapshotDate;
    this.accessRequests = new AccessRequests(this.channel, this);
    this.accessRequestEventsHistory = new AccessRequestEventsHistory(this.channel, this);
    this.accessRequestsHistory = new AccessRequestsHistory(this.channel, this);
    this.accountAttachments = new AccountAttachments(this.channel, this);
    this.accountAttachmentsHistory = new AccountAttachmentsHistory(this.channel, this);
    this.accountGrants = new AccountGrants(this.channel, this);
    this.accountGrantsHistory = new AccountGrantsHistory(this.channel, this);
    this.accountPermissions = new AccountPermissions(this.channel, this);
    this.accountResources = new AccountResources(this.channel, this);
    this.accountResourcesHistory = new AccountResourcesHistory(this.channel, this);
    this.accounts = new Accounts(this.channel, this);
    this.accountsHistory = new AccountsHistory(this.channel, this);
    this.activities = new Activities(this.channel, this);
    this.approvalWorkflowApprovers = new ApprovalWorkflowApprovers(this.channel, this);
    this.approvalWorkflowApproversHistory =
        new ApprovalWorkflowApproversHistory(this.channel, this);
    this.approvalWorkflowSteps = new ApprovalWorkflowSteps(this.channel, this);
    this.approvalWorkflowStepsHistory = new ApprovalWorkflowStepsHistory(this.channel, this);
    this.approvalWorkflows = new ApprovalWorkflows(this.channel, this);
    this.approvalWorkflowsHistory = new ApprovalWorkflowsHistory(this.channel, this);
    this.controlPanel = new ControlPanel(this.channel, this);
    this.healthChecks = new HealthChecks(this.channel, this);
    this.identityAliases = new IdentityAliases(this.channel, this);
    this.identityAliasesHistory = new IdentityAliasesHistory(this.channel, this);
    this.identitySets = new IdentitySets(this.channel, this);
    this.identitySetsHistory = new IdentitySetsHistory(this.channel, this);
    this.managedSecrets = new ManagedSecrets(this.channel, this);
    this.nodes = new Nodes(this.channel, this);
    this.nodesHistory = new NodesHistory(this.channel, this);
    this.organizationHistory = new OrganizationHistory(this.channel, this);
    this.peeringGroupNodes = new PeeringGroupNodes(this.channel, this);
    this.peeringGroupPeers = new PeeringGroupPeers(this.channel, this);
    this.peeringGroupResources = new PeeringGroupResources(this.channel, this);
    this.peeringGroups = new PeeringGroups(this.channel, this);
    this.policies = new Policies(this.channel, this);
    this.policiesHistory = new PoliciesHistory(this.channel, this);
    this.proxyClusterKeys = new ProxyClusterKeys(this.channel, this);
    this.queries = new Queries(this.channel, this);
    this.remoteIdentities = new RemoteIdentities(this.channel, this);
    this.remoteIdentitiesHistory = new RemoteIdentitiesHistory(this.channel, this);
    this.remoteIdentityGroups = new RemoteIdentityGroups(this.channel, this);
    this.remoteIdentityGroupsHistory = new RemoteIdentityGroupsHistory(this.channel, this);
    this.replays = new Replays(this.channel, this);
    this.resources = new Resources(this.channel, this);
    this.resourcesHistory = new ResourcesHistory(this.channel, this);
    this.roleResources = new RoleResources(this.channel, this);
    this.roleResourcesHistory = new RoleResourcesHistory(this.channel, this);
    this.roles = new Roles(this.channel, this);
    this.rolesHistory = new RolesHistory(this.channel, this);
    this.secretStores = new SecretStores(this.channel, this);
    this.secretEngines = new SecretEngines(this.channel, this);
    this.secretStoreHealths = new SecretStoreHealths(this.channel, this);
    this.secretStoresHistory = new SecretStoresHistory(this.channel, this);
    this.workflowApprovers = new WorkflowApprovers(this.channel, this);
    this.workflowApproversHistory = new WorkflowApproversHistory(this.channel, this);
    this.workflowRoles = new WorkflowRoles(this.channel, this);
    this.workflowRolesHistory = new WorkflowRolesHistory(this.channel, this);
    this.workflows = new Workflows(this.channel, this);
    this.workflowsHistory = new WorkflowsHistory(this.channel, this);
    this.testOptions = client.testOptions;
  }

  /** Creates a new strongDM API client with extra options. */
  public Client(String apiAccessKey, String apiSecretKey, ClientOptions options)
      throws RpcException {
    this.apiAccessKey = apiAccessKey.trim();
    this.apiSecretKey = Base64.getDecoder().decode(apiSecretKey.trim());
    this.pageLimit = options.getPageLimit();
    this.retryRateLimitErrors = options.getRetryRateLimitErrors();
    try {
      NettyChannelBuilder builder =
          NettyChannelBuilder.forAddress(options.getHost(), options.getPort());
      if (options.getInsecure()) {
        builder = builder.usePlaintext();
      } else {
        builder = builder.useTransportSecurity().sslContext(GrpcSslContexts.forClient().build());
      }
      this.channel = builder.build();
      this.accessRequests = new AccessRequests(this.channel, this);
      this.accessRequestEventsHistory = new AccessRequestEventsHistory(this.channel, this);
      this.accessRequestsHistory = new AccessRequestsHistory(this.channel, this);
      this.accountAttachments = new AccountAttachments(this.channel, this);
      this.accountAttachmentsHistory = new AccountAttachmentsHistory(this.channel, this);
      this.accountGrants = new AccountGrants(this.channel, this);
      this.accountGrantsHistory = new AccountGrantsHistory(this.channel, this);
      this.accountPermissions = new AccountPermissions(this.channel, this);
      this.accountResources = new AccountResources(this.channel, this);
      this.accountResourcesHistory = new AccountResourcesHistory(this.channel, this);
      this.accounts = new Accounts(this.channel, this);
      this.accountsHistory = new AccountsHistory(this.channel, this);
      this.activities = new Activities(this.channel, this);
      this.approvalWorkflowApprovers = new ApprovalWorkflowApprovers(this.channel, this);
      this.approvalWorkflowApproversHistory =
          new ApprovalWorkflowApproversHistory(this.channel, this);
      this.approvalWorkflowSteps = new ApprovalWorkflowSteps(this.channel, this);
      this.approvalWorkflowStepsHistory = new ApprovalWorkflowStepsHistory(this.channel, this);
      this.approvalWorkflows = new ApprovalWorkflows(this.channel, this);
      this.approvalWorkflowsHistory = new ApprovalWorkflowsHistory(this.channel, this);
      this.controlPanel = new ControlPanel(this.channel, this);
      this.healthChecks = new HealthChecks(this.channel, this);
      this.identityAliases = new IdentityAliases(this.channel, this);
      this.identityAliasesHistory = new IdentityAliasesHistory(this.channel, this);
      this.identitySets = new IdentitySets(this.channel, this);
      this.identitySetsHistory = new IdentitySetsHistory(this.channel, this);
      this.managedSecrets = new ManagedSecrets(this.channel, this);
      this.nodes = new Nodes(this.channel, this);
      this.nodesHistory = new NodesHistory(this.channel, this);
      this.organizationHistory = new OrganizationHistory(this.channel, this);
      this.peeringGroupNodes = new PeeringGroupNodes(this.channel, this);
      this.peeringGroupPeers = new PeeringGroupPeers(this.channel, this);
      this.peeringGroupResources = new PeeringGroupResources(this.channel, this);
      this.peeringGroups = new PeeringGroups(this.channel, this);
      this.policies = new Policies(this.channel, this);
      this.policiesHistory = new PoliciesHistory(this.channel, this);
      this.proxyClusterKeys = new ProxyClusterKeys(this.channel, this);
      this.queries = new Queries(this.channel, this);
      this.remoteIdentities = new RemoteIdentities(this.channel, this);
      this.remoteIdentitiesHistory = new RemoteIdentitiesHistory(this.channel, this);
      this.remoteIdentityGroups = new RemoteIdentityGroups(this.channel, this);
      this.remoteIdentityGroupsHistory = new RemoteIdentityGroupsHistory(this.channel, this);
      this.replays = new Replays(this.channel, this);
      this.resources = new Resources(this.channel, this);
      this.resourcesHistory = new ResourcesHistory(this.channel, this);
      this.roleResources = new RoleResources(this.channel, this);
      this.roleResourcesHistory = new RoleResourcesHistory(this.channel, this);
      this.roles = new Roles(this.channel, this);
      this.rolesHistory = new RolesHistory(this.channel, this);
      this.secretStores = new SecretStores(this.channel, this);
      this.secretEngines = new SecretEngines(this.channel, this);
      this.secretStoreHealths = new SecretStoreHealths(this.channel, this);
      this.secretStoresHistory = new SecretStoresHistory(this.channel, this);
      this.workflowApprovers = new WorkflowApprovers(this.channel, this);
      this.workflowApproversHistory = new WorkflowApproversHistory(this.channel, this);
      this.workflowRoles = new WorkflowRoles(this.channel, this);
      this.workflowRolesHistory = new WorkflowRolesHistory(this.channel, this);
      this.workflows = new Workflows(this.channel, this);
      this.workflowsHistory = new WorkflowsHistory(this.channel, this);
    } catch (Exception e) {
      throw Plumbing.convertExceptionToPorcelain(e);
    }
    this.testOptions = new HashMap<String, Object>();
  }

  public SnapshotClient snapshotAt(Date date) {
    Client copy = new Client(this);
    copy.snapshotDate = date;
    return new SnapshotClient(copy);
  }

  protected io.grpc.CallCredentials getCallCredentials(
      String methodName, com.google.protobuf.Message req) {
    return new SigningCallCredential(this.apiAccessKey, this.sign(methodName, req.toByteArray()));
  }

  public String sign(String methodName, byte[] message) {
    Calendar utcCalendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    int day = utcCalendar.get(Calendar.DATE);
    int month = utcCalendar.get(Calendar.MONTH) + 1;
    int year = utcCalendar.get(Calendar.YEAR);
    String utcdatestring = String.format("%04d-%02d-%02d", year, month, day);
    try {
      byte[] signingKey = hmac_digest(this.apiSecretKey, utcdatestring.getBytes("UTF-8"));
      signingKey = hmac_digest(signingKey, "sdm_api_v1".getBytes("UTF-8"));

      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      digest.update(methodName.getBytes("UTF-8"));
      digest.update("\n".getBytes("UTF-8"));
      digest.update(message);
      byte[] messageHash = digest.digest();
      return new String(Base64.getEncoder().encode(hmac_digest(signingKey, messageHash)));
    } catch (Exception e) {
      return "";
    }
  }

  private byte[] hmac_digest(byte[] key, byte[] message) {
    try {
      String HMAC_SHA256 = "HmacSHA256";
      Mac sha256_HMAC = Mac.getInstance(HMAC_SHA256);
      SecretKeySpec keySpec = new SecretKeySpec(key, HMAC_SHA256);
      sha256_HMAC.init(keySpec);
      return sha256_HMAC.doFinal(message);
    } catch (Exception e) {
      return new byte[] {};
    }
  }

  private final ManagedChannel channel;

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close() throws InterruptedException {
    return this.close(10, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long secs) throws InterruptedException {
    return this.close(secs, TimeUnit.SECONDS);
  }

  /**
   * Attempts to close the underlying grpc connection and waits for ongoing calls to terminate. It
   * will return whether it succeeded before timing out. Can be called multiple times safely.
   */
  public boolean close(long timeout, TimeUnit unit) throws InterruptedException {
    if (!this.channel.isShutdown()) {
      this.channel.shutdown();
    }
    if (this.channel.isTerminated()) {
      return true;
    }
    return this.channel.awaitTermination(timeout, unit);
  }

  public long exponentialBackoff(int retries, Deadline deadline) {
    if (retries == 0) {
      return applyDeadline(this.baseRetryDelay, deadline);
    }
    double backoff = this.baseRetryDelay;
    double max = this.maxRetryDelay;
    while (backoff < max && retries > 0) {
      backoff *= this.retryFactor;
      retries--;
    }
    if (backoff > max) {
      backoff = max;
    }
    backoff *= 1 + this.retryJitter * (new Random().nextDouble() * 2 - 1);
    if (backoff < 0) {
      return 0;
    }

    return applyDeadline((long) backoff, deadline);
  }

  private long applyDeadline(long delay, Deadline deadline) {
    if (deadline == null) {
      return delay;
    }
    return Long.max(0, Long.min(delay, deadline.timeRemaining(TimeUnit.MILLISECONDS)));
  }

  public boolean shouldRetry(int retries, Exception e, Deadline deadline) {
    if (deadline != null && deadline.isExpired()) {
      return false;
    }
    if (!(e instanceof io.grpc.StatusRuntimeException)) {
      return false;
    }
    com.google.rpc.Status status = io.grpc.protobuf.StatusProto.fromThrowable(e);
    if (this.retryRateLimitErrors && status.getCode() == Code.RESOURCE_EXHAUSTED_VALUE) {
      return true;
    }
    return retries <= 3
        && (status.getCode() == Code.INTERNAL_VALUE || status.getCode() == Code.UNAVAILABLE_VALUE);
  }

  protected Map<String, Object> testOptions;
}
